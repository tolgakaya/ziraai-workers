# Dispatcher Configuration
DISPATCHER_ID=dispatcher-001

# Provider Selection Strategy
# Options: FIXED, ROUND_ROBIN, COST_OPTIMIZED, QUALITY_FIRST, WEIGHTED, MESSAGE_BASED
PROVIDER_SELECTION_STRATEGY=FIXED

# Strategy-Specific Configuration

# FIXED Strategy: Always use specified provider
# Options: openai, gemini, anthropic
PROVIDER_FIXED=openai

# ROUND_ROBIN, COST_OPTIMIZED, QUALITY_FIRST: Comma-separated list of available providers
# Example: AVAILABLE_PROVIDERS=openai,gemini,anthropic
# AVAILABLE_PROVIDERS=openai,gemini,anthropic

# WEIGHTED Strategy: JSON array with provider weights
# Example: PROVIDER_WEIGHTS=[{"provider":"openai","weight":50},{"provider":"gemini","weight":30},{"provider":"anthropic","weight":20}]
# PROVIDER_WEIGHTS=[{"provider":"openai","weight":50},{"provider":"gemini","weight":30},{"provider":"anthropic","weight":20}]

# MESSAGE_BASED Strategy: No additional configuration needed (reads 'provider' field from request)

# RabbitMQ Configuration
RABBITMQ_URL=amqp://dev:devpass@localhost:5672/

# Queue Names
RAW_ANALYSIS_QUEUE=raw-analysis-queue
OPENAI_QUEUE=openai-analysis-queue
GEMINI_QUEUE=gemini-analysis-queue
ANTHROPIC_QUEUE=anthropic-analysis-queue
DLQ_QUEUE=analysis-dlq

# Retry Settings
MAX_RETRY_ATTEMPTS=3
RETRY_DELAY_MS=1000

# ============================================
# Redis Configuration (Two-Tier Rate Limiting)
# ============================================
REDIS_URL=redis://localhost:6379

# Redis Key Prefix for Dispatcher Rate Limiter
# IMPORTANT: Different from worker prefix to avoid conflicts
# Dispatcher: ziraai:dispatcher:ratelimit:
# Worker:     ziraai:worker:ratelimit:
REDIS_KEY_PREFIX=ziraai:dispatcher:ratelimit:

# Redis TTL (seconds) - How long to keep rate limit keys
REDIS_TTL=120

# ============================================
# Two-Tier Rate Limiting Configuration
# ============================================

# Enable/Disable Rate Limiting at Dispatcher Level
# If false, dispatcher will route messages without rate limit checks
# (Worker-level rate limiting still active as safety net)
RATE_LIMIT_ENABLED=true

# Delay for Rate Limited Messages (milliseconds)
# When rate limit exceeded at dispatcher, message is routed to delayed queue
# After this delay, message automatically returns to target queue via DLX
# Default: 30000ms (30 seconds)
RATE_LIMIT_DELAY_MS=30000

# ============================================
# Provider-Specific Rate Limits (requests per minute)
# ============================================

# Gemini API Rate Limit
# Free tier: 15 RPM, Paid tier: 2 QPM (2000 RPM)
# Conservative default: 500 RPM
GEMINI_RATE_LIMIT=500

# OpenAI API Rate Limit
# Tier 1: 500 RPM, Tier 2: 5000 RPM, Tier 3: 10000 RPM
# Conservative default: 5000 RPM (Tier 2)
OPENAI_RATE_LIMIT=5000

# Anthropic API Rate Limit
# Free: 50 RPM, Tier 1: 1000 RPM, Tier 2: 4000 RPM
# Conservative default: 400 RPM
ANTHROPIC_RATE_LIMIT=400

# ============================================
# Architecture Overview
# ============================================
#
# TWO-TIER RATE LIMITING SYSTEM:
#
# Tier 1: Dispatcher (Prevention Layer)
# - Checks rate limits BEFORE queueing messages
# - Routes rate-limited messages to delayed queues (TTL + DLX pattern)
# - Reduces unnecessary queue operations and costs
# - Redis key prefix: ziraai:dispatcher:ratelimit:{provider}
#
# Tier 2: Worker (Safety Net Layer)
# - Final rate limit check before API calls
# - Instant check (no waiting) - throws error if exceeded
# - NACK with requeue=true for rate limit errors
# - NACK with requeue=false (DLQ) for other errors
# - Redis key prefix: ziraai:worker:ratelimit:{provider}
#
# Message Flow:
# 1. WebAPI → raw-analysis-queue
# 2. Dispatcher checks rate limit (Tier 1)
#    - If OK: Route to provider queue (gemini/openai/anthropic)
#    - If exceeded: Route to delayed queue → auto-return after delay
# 3. Worker checks rate limit (Tier 2 - Safety Net)
#    - If OK: Process with AI provider
#    - If exceeded: NACK with requeue → automatic retry
# 4. Worker → plant-analysis-results queue → WebAPI
#
# Delayed Queue Pattern (RabbitMQ TTL + DLX):
# - Message sent to: gemini-analysis-queue-delayed-30000ms
# - Queue arguments: x-message-ttl=30000, x-dead-letter-routing-key=gemini-analysis-queue
# - After 30 seconds: Message automatically routes to gemini-analysis-queue
# - Zero application code needed for redelivery
#
# Benefits:
# - Proactive rate limiting (Dispatcher prevents unnecessary queuing)
# - Safety net (Worker catches edge cases)
# - Automatic redelivery (RabbitMQ handles delays, no app logic)
# - Cost efficient (Reduced requeue operations)
# - Scalable (Handles burst traffic gracefully)
